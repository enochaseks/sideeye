rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isMember(userId) {
      return request.auth.uid in resource.data.members;
    }
    
    function isRoomMember(roomId) {
      return isAuthenticated() && exists(/databases/$(database)/documents/sideRooms/$(roomId)/members/$(request.auth.uid));
    }

    function isValidTimestamp() {
      return request.time != null;
    }

    function isNotDeleted() {
      return !resource.data.deleted;
    }

    function isFollowing(userId) {
      return userId in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.following;
    }

    function isFollower(userId) {
      let userData = get(/databases/$(database)/documents/users/$(userId)).data;
      return ('followers' in userData) && (request.auth.uid in userData.followers || userData.followers.hasAny([request.auth.uid]));
    }

    // Check if the requesting user is a member of a specific forum
    function isForumMember(forumId) {
      // Assumes members are stored in an array on the forum document
      return isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/forums/$(forumId)).data.members;
    }

    // Users collection
    match /users/{userId} {
      // Allow reading public profile data by any authenticated user
      allow read: if request.auth != null;

      // Allow creating a user document only if the userId matches the authenticated user's UID
      allow create: if isOwner(userId);

      // Allow users to update their own specific profile fields (e.g., from settings page)
      allow update: if isOwner(userId) &&
                      request.resource.data.keys().hasOnly([
                        'name', 'username', 'profilePic', 'bio', 'location', 'website',
                        'isVerified', 'sourceCodeHash', 'sourceCodeSetupComplete',
                        'lastLogin', 'settings', 'preferences', 'updatedAt'
                      ]);

      // Allow updating ONLY the 'devices' array (specifically for source code verification flow)
      // Use request.writeFields which is specific to update operations
      allow update: if isOwner(userId) &&
                      request.writeFields.hasOnly(['devices']);

      // Allow users to delete their own account
      allow delete: if isOwner(userId);

      // Subcollection for users followed by {userId}
      match /following/{followingId} {
        allow read: if isAuthenticated(); // Anyone can see who a user follows
        allow write: if isOwner(userId); // Only the owner can modify their following list
      }

      // Subcollection for users who follow {userId}
      match /followers/{followerId} {
        allow read: if isAuthenticated(); // Anyone can see who follows a user
        // Allow a user (followerId) to add/remove themselves from {userId}'s followers list
        allow write: if isAuthenticated() && request.auth.uid == followerId;
      }

      // Allow owner full access to their notifications
      match /notifications/{notificationId} {
        allow list, read, write, delete: if isOwner(userId);
      }
    }

    // Posts collection
    match /posts/{postId} {
      // Anyone authenticated can read any post
      allow read: if request.auth != null;

      // Allow creating posts if authenticated, authorId matches, userId matches and required fields are present
      allow create: if isAuthenticated() &&
                      request.resource.data.authorId == request.auth.uid &&
                      request.resource.data.userId == request.auth.uid && // Verify userId as well
                      // Ensure required fields from PostData type (based on client code) exist
                      request.resource.data.content is string &&
                      request.resource.data.timestamp is timestamp && // Check 'timestamp'
                      request.resource.data.likes is number && // Check 'likes' is number
                      request.resource.data.likedBy is list && // Check 'likedBy' is list
                      request.resource.data.authorName is string && // Check 'authorName'
                      request.resource.data.authorAvatar is string && // Check authorAvatar
                      request.resource.data.comments is list && // Check comments is list
                      request.resource.data.tags is list && // Check tags is list
                      request.resource.data.isPrivate is bool &&
                      request.resource.data.reposts is number &&
                      request.resource.data.views is number &&
                      request.resource.data.isPinned is bool &&
                      request.resource.data.isEdited is bool &&
                      request.resource.data.isArchived is bool &&
                      request.resource.data.deleted is bool;
                      // Check for imageUrl only if present (optional)
                      // (request.resource.data.imageUrl == null || request.resource.data.imageUrl is string);

      // Allow the author to update specific fields of their post
      allow update: if isAuthenticated() && resource.data.authorId == request.auth.uid &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                        'content', 'imageUrl', 'isPrivate', 'deleted', 'isEdited', 'updatedAt'
                      ]);

      // Allow *any* authenticated user to update *only* the 'likes' field (for liking/unliking)
      allow update: if isAuthenticated() &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes']);

      // Allow the author to delete their post
      allow delete: if isAuthenticated() && resource.data.authorId == request.auth.uid;

      // Comments subcollection
      match /comments/{commentId} {
        allow read: if request.auth != null;
        // Allow creating comments if authenticated and authorId matches
        allow create: if isAuthenticated() &&
                        request.resource.data.authorId == request.auth.uid &&
                        request.resource.data.createdAt == request.time; // Ensure createdAt
        // Allow author to update/delete their comment
        allow update, delete: if isAuthenticated() && resource.data.authorId == request.auth.uid;
      }
    }

    // Forums collection
    match /forums/{forumId} {
      allow read: if isAuthenticated() && isNotDeleted();
      allow create: if isAuthenticated() && 
        request.resource.data.ownerId == request.auth.uid &&
        request.auth.uid in request.resource.data.members; // Ensure creator is a member
      allow update: if isAuthenticated() && (
        resource.data.ownerId == request.auth.uid ||
        isForumMember(forumId) // Use helper function
      );
      allow delete: if isAuthenticated() && 
        resource.data.ownerId == request.auth.uid;

      // Forum posts subcollection
      match /posts/{postId} {
        allow read: if isAuthenticated() && isNotDeleted() && (
          isForumMember(forumId) || // Use helper function
          get(/databases/$(database)/documents/forums/$(forumId)).data.ownerId == request.auth.uid
        );
        allow create: if isAuthenticated() && 
          isForumMember(forumId) && // Use helper function
          request.resource.data.authorId == request.auth.uid;
        allow update: if isAuthenticated() && 
          resource.data.authorId == request.auth.uid;
        allow delete: if isAuthenticated() && (
          resource.data.authorId == request.auth.uid ||
          get(/databases/$(database)/documents/forums/$(forumId)).data.ownerId == request.auth.uid
        );
      }
    }

    // Side Rooms collection
    match /sideRooms/{roomId} {
      allow read: if isAuthenticated() && (
        !resource.data.isPrivate || // Public rooms
        isSideRoomMember(roomId)    // Or members of private rooms
      );
      
      allow create: if isAuthenticated() && 
        request.resource.data.ownerId == request.auth.uid; // Must be owner
        
      allow update: if isAuthenticated() && (
        resource.data.ownerId == request.auth.uid ||
        isSideRoomMember(roomId) // Use helper function
      );
        
      allow delete: if isAuthenticated() && 
        resource.data.ownerId == request.auth.uid; // Only owner can delete

      // Room members subcollection
      match /members/{userId} {
        allow read: if isAuthenticated();
        // Allow owner to add members, or users to add themselves? (Current allows self-add)
        allow create: if isAuthenticated() && (request.auth.uid == userId || get(/databases/$(database)/documents/sideRooms/$(roomId)).data.ownerId == request.auth.uid);
        allow update: if isAuthenticated() && request.auth.uid == userId; // Can users update their member status?
        // Allow owner to remove members, or users to remove themselves
        allow delete: if isAuthenticated() && (
          request.auth.uid == userId ||
          get(/databases/$(database)/documents/sideRooms/$(roomId)).data.ownerId == request.auth.uid
        );
      }

      // Room messages subcollection
      match /messages/{messageId} {
        allow read: if isAuthenticated() && isSideRoomMember(roomId) && isNotDeleted();
        allow create: if isAuthenticated() && 
          isSideRoomMember(roomId) &&
          request.resource.data.authorId == request.auth.uid;
        // Allow author to update own message
        allow update: if isAuthenticated() &&
          resource.data.authorId == request.auth.uid;
        // Allow author or room owner to delete messages
        allow delete: if isAuthenticated() && (
          resource.data.authorId == request.auth.uid ||
          get(/databases/$(database)/documents/sideRooms/$(roomId)).data.ownerId == request.auth.uid
        );
      }

      // WebRTC signaling subcollection
      match /signaling/{signalId} {
        allow read, write: if isAuthenticated() && isSideRoomMember(roomId);
      }
    }

    // Trash collection
    match /trash/{itemId} {
      allow read: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.ownerId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.ownerId == request.auth.uid;
    }

    // Content moderation collection
    match /moderation/{itemId} {
      allow read: if isAuthenticated() && (
        resource.data.authorId == request.auth.uid ||
        resource.data.moderatorId == request.auth.uid
      );
      allow create: if isAuthenticated() && request.resource.data.moderatorId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.moderatorId == request.auth.uid;
    }

    // Notifications collection
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.recipientId;
      allow create: if isAuthenticated();
      allow update: if isAuthenticated() && request.auth.uid == resource.data.recipientId;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.recipientId;
    }
  }
}